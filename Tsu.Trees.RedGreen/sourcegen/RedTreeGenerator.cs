using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Tsu.Trees.RedGreen.SourceGenerator.Model;

namespace Tsu.Trees.RedGreen.SourceGenerator;

internal static class RedTreeGenerator
{
    public static void RegisterRedSyntaxOutput(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        context.RegisterSourceOutput(trees, (ctx, tree) =>
        {
            try
            {
                var builder = new StringBuilder();
                var writer = new IndentedTextWriter(new StringWriter(builder));

                writer.WriteLine("// <auto-generated />");
                writer.WriteLineNoTabs("");

                writer.WriteLine("#nullable enable");
                writer.WriteLineNoTabs("");

                writer.WriteLine("using System.Diagnostics;");
                writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
                writer.WriteLine("using System.Linq;");
                writer.WriteLineNoTabs("");

                writer.WriteLine("namespace {0}", tree.RedBase.ContainingNamespace.ToCSharpString());
                writer.WriteLine('{');
                writer.Indent++;

                {
                    writer.WriteRedRoot(tree, tree.Root);
                }

                writer.Indent--;
                writer.WriteLine('}');
                writer.WriteLineNoTabs("");

                writer.Flush();
                ctx.AddSource($"{tree.Suffix}.Red.g.cs", builder.ToSourceText());
            }
            catch (Exception ex)
            {
                D.WriteLine(ex.ToString());
            }
        });
    }

    private static void WriteRedRoot(this IndentedTextWriter writer, Tree tree, Node root)
    {
        writer.WriteLine("abstract partial class {0} : global::Tsu.Trees.RedGreen.IRedNode<{1}, {2}>",
            tree.RedBase.Name,
            tree.RedBase.ToCSharpString(),
            tree.KindEnum.ToCSharpString());
        writer.WriteLine('{');
        writer.Indent++;
        {
            writer.WriteLine("private readonly {0}? _parent;", tree.RedBase.ToCSharpString());
            writer.WriteLineNoTabs("");

            writer.WriteLine("private protected {0}({1} green, {2}? parent)",
                tree.RedBase.Name,
                tree.GreenBase.ToCSharpString(),
                tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("this._parent = parent;");
                writer.WriteLine("this.Green = green;");
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");

            foreach (var component in root.Components)
            {
                writer.WriteLine("public {0} {1} => this.Green.{1};", component.Type.ToCSharpString(), component.PropertyName);
            }
            writer.WriteLine("internal {0} Green {{ get; }}", tree.GreenBase.ToCSharpString());
            writer.WriteLine("public {0}? Parent => _parent;", tree.RedBase.ToCSharpString());
            writer.WriteLine("internal int SlotCount => this.Green.SlotCount;", tree.RedBase.ToCSharpString());
            writer.WriteLineNoTabs("");

            #region bool IsEquivalentTo([NotNullWhen(true)] TRedRoot? other)
            writer.WriteLine("public bool IsEquivalentTo({0}? other)", tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("if (this == other) return true;");
                writer.WriteLine("if (other == null) return false;");
                writer.WriteLineNoTabs("");
                writer.WriteLine("return this.Green.IsEquivalentTo(other.Green);");
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion bool IsEquivalentTo([NotNullWhen(true)] TRedRoot? other)

            #region bool Contains(TRedRoot other)
            writer.WriteLine("public bool Contains({0} other)", tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("for (var node = other; node != null; node = node.Parent)");
                writer.WriteLine('{');
                writer.Indent++;
                {
                    writer.WriteLine("if (node == this)");
                    writer.Indent++;
                    writer.WriteLine("return true;");
                    writer.Indent--;
                }
                writer.Indent--;
                writer.WriteLine('}');
                writer.WriteLineNoTabs("");
                writer.WriteLine("return false;");
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion bool Contains(TRedRoot other)

            writer.WriteLine("internal abstract {0}? GetNodeSlot(int index);", tree.RedBase.ToCSharpString());
            writer.WriteLineNoTabs("");

            #region TRedRoot GetRequiredNodeSlot(int slot)
            writer.WriteLine("internal {0} GetRequiredNodeSlot(int index)", tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("var node = this.GetNodeSlot(index);");
                writer.WriteLine("Debug.Assert(node != null);");
                writer.WriteLine("return node!;");
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion TRedRoot GetRequiredNodeSlot(int slot)

            #region IEnumerable<TRedRoot> ChildNodes()
            writer.WriteLine("public global::System.Collections.Generic.IEnumerable<{0}> ChildNodes()", tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("var count = this.SlotCount;");
                writer.WriteLine("for (var index = 0; index < count; index++)");
                writer.Indent++;
                writer.WriteLine("yield return this.GetRequiredNodeSlot(index);");
                writer.Indent--;
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion IEnumerable<TRedRoot> ChildNodes()

            #region IEnumerable<SyntaxNode> Ancestors
            writer.WriteLine("public global::System.Collections.Generic.IEnumerable<{0}> Ancestors() =>", tree.RedBase.ToCSharpString());
            writer.Indent++;
            writer.WriteLine("this.Parent?.AncestorsAndSelf() ?? global::System.Linq.Enumerable.Empty<{0}>();", tree.RedBase.ToCSharpString());
            writer.Indent--;
            writer.WriteLineNoTabs("");
            #endregion IEnumerable<SyntaxNode> Ancestors

            #region IEnumerable<TRedRoot> AncestorsAndSelf()
            writer.WriteLine("public global::System.Collections.Generic.IEnumerable<{0}> AncestorsAndSelf()", tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("for (var node = this; node != null; node = node.Parent)");
                writer.Indent++;
                writer.WriteLine("yield return node;");
                writer.Indent--;
            }
            writer.Indent--;
            writer.WriteLine('}');
            #endregion IEnumerable<TRedRoot> AncestorsAndSelf()

            #region TNode? FirstAncestorOrSelf<TNode>(Func<TNode, bool>? predicate = null) where TNode : TRedRoot
            writer.WriteLine("public TNode? FirstAncestorOrSelf<TNode>(Func<TNode, bool>? predicate = null) where TNode : {0}", tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("for (var node = this; node != null; node = node.Parent)");
                writer.WriteLine('{');
                writer.Indent++;
                {
                    writer.WriteLine("if (node is TNode tnode && (predicate == null || predicate(tnode)))");
                    writer.Indent++;
                    writer.WriteLine("return tnode;");
                    writer.Indent--;
                }
                writer.Indent--;
                writer.WriteLine('}');
                writer.WriteLineNoTabs("");
                writer.WriteLine("return null;");
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion TNode? FirstAncestorOrSelf<TNode>(Func<TNode, bool>? predicate = null) where TNode : TRedRoot

            #region TNode? FirstAncestorOrSelf<TNode, TArg>(Func<TNode, TArg, bool> predicate, TArg argument) where TNode : TRedRoot
            writer.WriteLine("public TNode? FirstAncestorOrSelf<TNode, TArg>(Func<TNode, TArg, bool> predicate, TArg argument) where TNode : {0}",
                tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("for (var node = this; node != null; node = node.Parent)");
                writer.WriteLine('{');
                writer.Indent++;
                {
                    writer.WriteLine("if (node is TNode tnode && (predicate == null || predicate(tnode, argument)))");
                    writer.Indent++;
                    writer.WriteLine("return tnode;");
                    writer.Indent--;
                }
                writer.Indent--;
                writer.WriteLine('}');
                writer.WriteLineNoTabs("");
                writer.WriteLine("return null;");
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion TNode? FirstAncestorOrSelf<TNode, TArg>(Func<TNode, TArg, bool> predicate, TArg argument) where TNode : TRedRoot

            #region IEnumerable<TRedRoot> DescendantNodes(Func<TRedRoot, bool>? descendIntoChildren = null)
            writer.WriteLine("public global::System.Collections.Generic.IEnumerable<{0}> DescendantNodes(Func<{0}, bool>? descendIntoChildren = null)",
                tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("var stack = new Stack<{0}>(24);", tree.RedBase.ToCSharpString());
                writer.WriteLine("foreach (var child in this.ChildNodes())");
                writer.Indent++;
                writer.WriteLine("stack.Push(child);");
                writer.Indent--;
                writer.WriteLineNoTabs("");
                writer.WriteLine("while (stack.Count > 0)");
                writer.WriteLine('{');
                writer.Indent++;
                {
                    writer.WriteLine("var current = stack.Pop();");
                    writer.WriteLineNoTabs("");
                    writer.WriteLine("yield return current;");
                    writer.WriteLineNoTabs("");
                    writer.WriteLine("foreach (var child in current.ChildNodes().Reverse())");
                    writer.WriteLine('{');
                    writer.Indent++;
                    writer.WriteLine("stack.Push(child);");
                    writer.Indent--;
                    writer.WriteLine('}');
                }
                writer.Indent--;
                writer.WriteLine('}');
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");
            #endregion IEnumerable<TRedRoot> DescendantNodes(Func<TRedRoot, bool>? descendIntoChildren = null)

            #region IEnumerable<TRedRoot> DescendantNodesAndSelf(Func<TRedRoot, bool>? descendIntoChildren = null)
            writer.WriteLine("public global::System.Collections.Generic.IEnumerable<{0}> DescendantNodesAndSelf(Func<{0}, bool>? descendIntoChildren = null)",
                tree.RedBase.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLine("var stack = new Stack<{0}>(24);", tree.RedBase.ToCSharpString());
                writer.WriteLine("stack.Push(this);");
                writer.WriteLineNoTabs("");
                writer.WriteLine("while (stack.Count > 0)");
                writer.WriteLine('{');
                writer.Indent++;
                {
                    writer.WriteLine("var current = stack.Pop();");
                    writer.WriteLineNoTabs("");
                    writer.WriteLine("yield return current;");
                    writer.WriteLineNoTabs("");
                    writer.WriteLine("foreach (var child in current.ChildNodes().Reverse())");
                    writer.WriteLine('{');
                    writer.Indent++;
                    writer.WriteLine("stack.Push(child);");
                    writer.Indent--;
                    writer.WriteLine('}');
                }
                writer.Indent--;
                writer.WriteLine('}');
            }
            writer.Indent--;
            writer.WriteLine('}');
            #endregion IEnumerable<TRedRoot> DescendantNodesAndSelf(Func<TRedRoot, bool>? descendIntoChildren = null)
        }
        writer.Indent--;
        writer.WriteLine('}');
    }
}