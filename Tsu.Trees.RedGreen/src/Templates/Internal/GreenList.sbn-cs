{{~
if create_lists
    green_node = green_base.csharp | not_null
~}}
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// Modified by the Tsu (https://github.com/GGG-KILLER/Tsu) project for embedding into other projects.
// <auto-generated />

#nullable enable

namespace {{ green_base.namespace | not_global }}
{
    {{ green_base.accessibility }} abstract partial class {{ suffix }}List : {{ green_node }}
    {
        {{ green_base.accessibility }} {{ suffix }}List()
            : base(ListKind{{~ for component in root.components_without_kind ~}}, default({{ component.type.csharp | not_null }})!{{~ end ~}})
        {
        }

        {{ green_base.accessibility }} static {{ green_node }} List({{ green_node }} child) => child;

        {{ green_base.accessibility }} static WithTwoChildren List({{ green_node }} child0, {{ green_node }} child1)
        {
            global::System.Diagnostics.Debug.Assert(child0 != null);
            global::System.Diagnostics.Debug.Assert(child1 != null);

            return new WithTwoChildren(child0, child1);
        }

        {{ green_base.accessibility }} static WithThreeChildren List({{ green_node }} child0, {{ green_node }} child1, {{ green_node }} child2)
        {
            global::System.Diagnostics.Debug.Assert(child0 != null);
            global::System.Diagnostics.Debug.Assert(child1 != null);
            global::System.Diagnostics.Debug.Assert(child2 != null);

            return new WithThreeChildren(child0, child1, child2);
        }

        {{ green_base.accessibility }} static {{ suffix }}List List({{ green_node }}[] children)
        {
            return new WithManyChildren(children);
        }

        {{ green_base.accessibility }} abstract void CopyTo({{ green_node }}[] array, int offset);

        {{ green_base.accessibility }} static {{ green_node }}? Concat({{ green_node }}? left, {{ green_node }}? right)
        {
            if (left == null)
            {
                return right;
            }

            if (right == null)
            {
                return left;
            }

            var rightList = right as {{ suffix }}List;
            if (left is {{ suffix }}List leftList)
            {
                if (rightList != null)
                {
                    var tmp = new {{ green_node }}[left.SlotCount + right.SlotCount];
                    leftList.CopyTo(tmp, 0);
                    rightList.CopyTo(tmp, left.SlotCount);
                    return List(tmp);
                }
                else
                {
                    var tmp = new {{ green_node }}[left.SlotCount + 1];
                    leftList.CopyTo(tmp, 0);
                    tmp[left.SlotCount] = right;
                    return List(tmp);
                }
            }
            else if (rightList != null)
            {
                var tmp = new {{ green_node }}[rightList.SlotCount + 1];
                tmp[0] = left;
                rightList.CopyTo(tmp, 1);
                return List(tmp);
            }
            else
            {
                return List(left, right);
            }
        }

        {{~ if create_visitors || create_walker ~}}
        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept({{ green_base.namespace }}.{{ suffix }}Visitor visitor) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");
        {{~ end ~}}

        {{~ if create_visitors || create_rewriter ~}}
        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<TResult> visitor) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");
        {{~ end ~}}

        {{~ if create_visitors ~}}
        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<T1, TResult> visitor, T1 arg1) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");
        {{~ end ~}}
    }
}
{{~ end ~}}