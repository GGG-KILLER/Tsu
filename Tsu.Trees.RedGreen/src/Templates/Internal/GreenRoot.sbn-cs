// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// Modified by the Tsu (https://github.com/GGG-KILLER/Tsu) project for embedding into other projects.
// <auto-generated />

#nullable enable

namespace {{ green_base.namespace | not_global }}
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;

    abstract partial class {{ green_base.name }}
    {
{{~ if create_lists ~}}
        public const {{ kind_enum.csharp }} ListKind = {{ kind_enum.csharp }}.List;
{{~ end ~}}

{{~ for component in root.components ~}}
        protected readonly {{ component.type.csharp }} {{ component.field_name }};
{{~ end ~}}
        private byte _slotCount;

        protected {{ green_base.name }}({{- for component in root.components -}}
    {{ if !for.first }}, {{ end }}{{ component.type.csharp }} {{ component.parameter_name }}
{{- end -}})
        {
{{~ for component in root.components ~}}
            this.{{ component.field_name }} = {{ component.parameter_name }};
{{~ end ~}}
        }

{{ for component in root.components ~}}
        public {{ component.type.csharp }} {{ component.property_name }} => this.{{ component.field_name }};
{{~ end ~}}

        public int SlotCount
        {
            get
            {
                int count = this._slotCount;
                if (count == byte.MaxValue)
                    count = this.GetSlotCount();
                return count;
            }
            protected set => _slotCount = (byte) value;
        }

{{~ if create_lists ~}}
        public bool IsList => this._kind == ListKind;
{{~ else ~}}
        public bool IsList => false;
{{~ end ~}}

        public abstract {{ green_base.csharp | not_null }}? GetSlot(int index);

        public {{ green_base.csharp | not_null }} GetRequiredSlot(int index)
        {
            var node = this.GetSlot(index);
            Debug.Assert(node != null);
            return node!;
        }

        protected virtual int GetSlotCount() => _slotCount;

        public {{ green_base.namespace }}.Child{{ suffix }}List ChildNodes() =>
            new {{ green_base.namespace }}.Child{{ suffix }}List(this);

        public IEnumerable<{{ green_base.csharp | not_null }}> EnumerateDescendants()
        {
            yield return this;

            var stack = new Stack<{{ green_base.namespace }}.Child{{ suffix }}List.Enumerator>(24);
            stack.Push(ChildNodes().GetEnumerator());

            while (stack.Count > 0)
            {
                var en = stack.Pop();
                if (!en.MoveNext())
                {
                    // no more down this branch
                    continue;
                }

                var current = en.Current;
                stack.Push(en); // put it back on stack (struct enumerator)

                yield return current;

                stack.Push(current.ChildNodes().GetEnumerator());
                continue;
            }
        }

        public virtual bool IsEquivalentTo([NotNullWhen(true)] {{ green_base.csharp | not_null }}? other)
        {
            if (this == other) return true;
            if (other == null) return false;
{{~ for component in root.components ~}}
            if (this.{{ component.property_name }} != other.{{ component.property_name }}) return false;
{{~ end ~}}

            var n = this.SlotCount;
            if (n != other.SlotCount) return false;

            for (int i = 0; i < n; i++)
            {
                var thisChild = this.GetSlot(i);
                var otherChild = other.GetSlot(i);
                if (thisChild != null && otherChild != null && !thisChild.IsEquivalentTo(otherChild))
                {
                    return false;
                }
            }

            return true;
        }

        /*
         * There are 3 overloads of this, because most callers already know what they have is a List<T> and only transform it.
         * In those cases List<TFrom> performs much better.
         * In other cases, the type is unknown / is IEnumerable<T>, where we try to find the best match.
         * There is another overload for IReadOnlyList, since most collections already implement this, so checking for it will
         * perform better then copying to a List<T>, though not as good as List<T> directly.
         */
        public static {{ green_base.csharp | not_null }}? CreateList<TFrom>(IEnumerable<TFrom>? enumerable, Func<TFrom, {{ green_base.csharp | not_null }}> select)
            => enumerable switch
            {
                null => null,
                List<TFrom> l => CreateList(l, select),
                IReadOnlyList<TFrom> l => CreateList(l, select),
                _ => CreateList(enumerable.ToList(), select)
            };

        public static {{ green_base.csharp | not_null }}? CreateList<TFrom>(List<TFrom> list, Func<TFrom, {{ green_base.csharp | not_null }}> select)
        {
            switch (list.Count)
            {
                case 0:
                    return null;
                case 1:
                    return select(list[0]);
                case 2:
                    return {{ green_base.namespace }}.{{ suffix }}List.List(select(list[0]), select(list[1]));
                case 3:
                    return {{ green_base.namespace }}.{{ suffix }}List.List(select(list[0]), select(list[1]), select(list[2]));
                default:
                {
                    var array = new {{ green_base.csharp | not_null }}[list.Count];
                    for (int i = 0; i < array.Length; i++)
                        array[i] = select(list[i]);
                    return {{ green_base.namespace }}.{{ suffix }}List.List(array);
                }
            }
        }

        public static {{ green_base.csharp | not_null }}? CreateList<TFrom>(IReadOnlyList<TFrom> list, Func<TFrom, {{ green_base.csharp | not_null }}> select)
        {
            switch (list.Count)
            {
                case 0:
                    return null;
                case 1:
                    return select(list[0]);
                case 2:
                    return {{ suffix }}List.List(select(list[0]), select(list[1]));
                case 3:
                    return {{ suffix }}List.List(select(list[0]), select(list[1]), select(list[2]));
                default:
                {
                    var array = new {{ green_base.csharp | not_null }}[list.Count];
                    for (int i = 0; i < array.Length; i++)
                        array[i] = select(list[i]);
                    return {{ suffix }}List.List(array);
                }
            }
        }

        public {{ red_base.csharp | not_null }} CreateRed() => this.CreateRed(null);
        public abstract {{ red_base.csharp | not_null }} CreateRed({{ red_base.csharp | not_null }}? parent);

{{~ if create_visitors || create_walker ~}}
        public abstract void Accept({{ green_base.namespace }}.{{ suffix }}Visitor visitor);
{{~ end ~}}
{{~ if create_visitors || create_rewriter ~}}
        public abstract TResult? Accept<TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<TResult> visitor);
{{~ end ~}}
{{~ if create_visitors ~}}
        public abstract TResult? Accept<T1, TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<T1, TResult> visitor, T1 arg1);
        public abstract TResult? Accept<T1, T2, TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2);
        public abstract TResult? Accept<T1, T2, T3, TResult>({{ green_base.namespace }}.{{ suffix }}Visitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3);
{{~ end ~}}
    }
}