{{-
func isnt_passed_to_parent(comp)
    ret !comp.pass_to_base
end
-}}
// <auto-generated />

#nullable enable


namespace {{ red_base.namespace | not_global }}
{
{{~
for node in non_root_nodes
    base = node.base
    if base.namespace == green_base.namespace && base.name == green_base.name
        base = red_base
    end
~}}
    {{ red_base.accessibility }} {{ if node.type.is_abstract }}abstract {{ end }}partial class {{ node.type.name }} : {{ red_base.namespace}}.{{ base.name }}
    {
        {{~ if node.descendants | array.size == 0 ~}}
            {{~ for child in node.children ~}}
        private {{ child | field_type false | not_null }}? {{ child.field_name }};
            {{~ end ~}}
        {{~ end ~}}

        internal {{ node.type.name }}({{ green_base.csharp | not_null }} green, {{ red_base.csharp | not_null }}? parent)
            : base(green, parent)
        {
        }

        {{~ ## Components ## ~}}
        {{~ if node.descendants | array.size > 0 ~}}
            {{~ for data in node.node_components ~}}
        public abstract {{ data | property_type false }} {{ data.property_name }} { get; }
            {{~ end ~}}
        {{~ else ~}}
            {{~ for data in node.extra_data ~}}
                {{~ if data.field_name == "_kind"; continue; end ~}}
        public {{ if data.pass_to_base }}override {{ end }} {{ data | property_type false }} {{ data.property_name }} => (({{ node.type.csharp | not_null }})this.Green).{{ data.property_name }};
            {{~ end ~}}
            {{~ for child in node.children ~}}
                {{~ if child.is_list ~}}
            public {{ if child.pass_to_base }}override {{ end }}{{ child | property_type false }} {{ child.property_name }} => new {{ child | property_type false }}(GetRed(ref this.{{ child.field_name }}, {{ for.index }}){{if !child.is_optional}}!{{end}});
                {{~ else ~}}
        public {{ if child.pass_to_base }}override {{ end }}{{ child | property_type false }} {{ child.property_name }} => GetRed(ref this.{{ child.field_name }}, {{ for.index }}){{if !child.is_optional}}!{{end}};
                {{~ end ~}}
            {{~ end ~}}
        {{~ end ~}}
        {{~ ## End Components ## ~}}

        {{~ ## GetNodeSlot ## ~}}
        {{~ if node.descendants | array.size == 0 ~}}
        internal override {{ red_base.csharp | not_null }}? GetNodeSlot(int index) =>
            {{~ if node.children | array.size == 0 ~}}
                null;
            {{~ else if node.children | array.size == 1 ~}}
                index == 0 ? GetRed(ref this.{{ node.children[0].field_name }}, 0){{ if !node.children[0].is_optional }}!{{ end }} : null;
            {{~ else ~}}
                index switch
                {
                    {{~ for child in node.children ~}}
                    {{ for.index }} => GetRed(ref this.{{ child.field_name }}, {{ for.index }}){{ if !child.is_optional }}!{{ end }},
                    {{~ end ~}}
                    _ => null
                };
            {{~ end ~}}
        {{~ end ~}}
        {{~ ## End GetNodeSlot ## ~}}

        {{~ ## Accept ## ~}}
        {{~ if !node.type.is_abstract && (create_visitors || create_walker) ~}}
        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept({{ red_base.namespace }}.{{ suffix }}Visitor visitor) =>
            visitor.Visit{{ node.type.name | no_suffix }}(this);
        {{~ end ~}}

        {{~ if !node.type.is_abstract && (create_visitors || create_rewriter) ~}}
        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<TResult> visitor) =>
            visitor.Visit{{ node.type.name | no_suffix }}(this);
        {{~ end ~}}

        {{~ if !node.type.is_abstract && create_visitors ~}}
        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<T1, TResult> visitor, T1 arg1) =>
            visitor.Visit{{ node.type.name | no_suffix }}(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.Visit{{ node.type.name | no_suffix }}(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.Visit{{ node.type.name | no_suffix }}(this, arg1, arg2, arg3);
        {{~ end ~}}
        {{~ ## End Accept ## ~}}

        {{~ ## TNode Update(...) ## ~}}
        {{~ if (node.descendants | array.size == 0) && (node.required_components | array.size > 0) ~}}
        public {{ node.type | as_red }} Update(
            {{~ for component in node.required_components ~}}
            {{~ ## property_type is used instead of parameter_type here due to it being an external facing method ## ~}}
            {{ component | property_type false }} {{ component.parameter_name }}{{ if !for.last }},{{ end }}
            {{~ end ~}}
        )
        {
            if (
                {{~ for component in node.required_components ~}}
                {{ if !for.first }}|| {{ end }}this.{{ component.property_name }} != {{ component.parameter_name }}
                {{~ end ~}}
            )
            {
                return {{ red_base.namespace }}.{{ suffix }}Factory.{{ node.type.name | no_suffix }}(
                    {{~ for component in node.required_components ~}}
                    {{ component.parameter_name }}{{ if !for.last }},{{ end }}
                    {{~ end ~}}
                );
            }

            return this;
        }
        {{~ end ~}}
        {{~ ## End TNode Update(...) ## ~}}

        {{~ ## TNode WithX(...) ## ~}}
        {{~ if (node.descendants | array.size == 0) && (node.required_components | array.size > 0) ~}}
        {{~ for target in node.required_components ~}}
        {{~ ## property_type is used instead of parameter_type here due to it being an external facing method ## ~}}
        public {{ node.type | as_red }} With{{ target.property_name }}({{ target | property_type false }} {{ target.parameter_name }}) =>
            this.Update(
            {{~ for component in node.required_components ~}}
                {{~ if target.parameter_name == component.parameter_name ~}}
                {{ component.parameter_name }}{{ if !for.last }},{{ end }}
                {{~ else ~}}
                this.{{ component.property_name }}{{ if !for.last }},{{ end }}
                {{~ end ~}}
            {{~ end ~}}
            );
        {{~ end ~}}
        {{~ end ~}}
        {{~ ## End TNode WithX(...) ## ~}}
    }
{{~ end ~}}
}