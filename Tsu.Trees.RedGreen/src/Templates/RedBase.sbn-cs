// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// Modified by the Tsu (https://github.com/GGG-KILLER/Tsu) project for embedding into other projects.
// <auto-generated />

#nullable enable

namespace {{ red_base.namespace | not_global }}
{
    abstract partial class {{ red_base.name }}
    {
        private readonly {{ red_base.csharp | not_null }}? _parent;

        private protected {{ red_base.name }}({{ green_base.csharp | not_null }} green, {{ red_base.csharp | not_null }}? parent)
        {
            this._parent = parent;
            this.Green = green;
        }

        public {{ kind_enum.csharp | not_null }} Kind => this.Green.Kind;
        {{~ for component in root.components_without_kind ~}}
        public abstract {{ component.type | as_red }} {{ component.property_name }} { get; }
        {{~ end ~}}
        internal {{ green_base.csharp | not_null }} Green { get; }
        public {{ red_base.csharp | not_null }}? Parent => _parent;
        internal int SlotCount => this.Green.SlotCount;
        internal bool IsList => this.Green.IsList;

        protected T? GetRed<T>(ref T? field, int index) where T : {{ red_base.csharp | not_null }}
        {
            var result = field;

            if (result == null)
            {
                var green = this.Green.GetSlot(index);
                if (green != null)
                {
                    global::System.Threading.Interlocked.CompareExchange(ref field, (T) green.CreateRed(this), null);
                    result = field;
                }
            }

            return result;
        }

        /// <summary>
        /// This works the same as GetRed, but intended to be used in lists
        /// The only difference is that the public parent of the node is not the list,
        /// but the list's parent. (element's grand parent).
        /// </summary>
        protected {{ red_base.csharp | not_null }}? GetRedElement(ref {{ red_base.csharp | not_null }}? element, int slot)
        {
            global::System.Diagnostics.Debug.Assert(IsList);

            var result = element;

            if (result == null)
            {
                var green = Green.GetRequiredSlot(slot);
                // passing list's parent
                global::System.Threading.Interlocked.CompareExchange(ref element, green.CreateRed(Parent), null);
                result = element;
            }

            return result;
        }

        public bool IsEquivalentTo({{ red_base.csharp | not_null }}? other)
        {
            if (this == other) return true;
            if (other == null) return false;

            return this.Green.IsEquivalentTo(other.Green);
        }

        public bool Contains({{ red_base.csharp | not_null }} other)
        {
            for (var node = other; node != null; node = node.Parent)
            {
                if (node == this)
                    return true;
            }

            return false;
        }

        internal abstract {{ red_base.csharp | not_null }}? GetNodeSlot(int index);

        internal {{ red_base.csharp | not_null }} GetRequiredNodeSlot(int index)
        {
            var node = this.GetNodeSlot(index);
            global::System.Diagnostics.Debug.Assert(node != null);
            return node!;
        }

        public abstract void Accept({{ red_base.namespace }}.{{ suffix }}Visitor visitor);
        public abstract TResult? Accept<TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<TResult> visitor);
        public abstract TResult? Accept<T1, TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<T1, TResult> visitor, T1 arg1);
        public abstract TResult? Accept<T1, T2, TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2);
        public abstract TResult? Accept<T1, T2, T3, TResult>({{ red_base.namespace }}.{{ suffix }}Visitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3);

        public global::System.Collections.Generic.IEnumerable<{{ red_base.csharp | not_null }}> ChildNodes()
        {
            var count = this.SlotCount;
            for (var index = 0; index < count; index++)
                yield return this.GetRequiredNodeSlot(index);
        }

        public global::System.Collections.Generic.IEnumerable<{{ red_base.csharp | not_null }}> Ancestors() =>
            this.Parent?.AncestorsAndSelf() ?? global::System.Linq.Enumerable.Empty<{{ red_base.csharp | not_null }}>();

        public global::System.Collections.Generic.IEnumerable<{{ red_base.csharp | not_null }}> AncestorsAndSelf()
        {
            for (var node = this; node != null; node = node.Parent)
                yield return node;
        }

        public TNode? FirstAncestorOrSelf<TNode>(Func<TNode, bool>? predicate = null) where TNode : {{ red_base.csharp | not_null }}
        {
            for (var node = this; node != null; node = node.Parent)
            {
                if (node is TNode tnode && (predicate == null || predicate(tnode)))
                    return tnode;
            }

            return null;
        }

        public TNode? FirstAncestorOrSelf<TNode, TArg>(Func<TNode, TArg, bool> predicate, TArg argument) where TNode : {{ red_base.csharp | not_null }}
        {
            for (var node = this; node != null; node = node.Parent)
            {
                if (node is TNode tnode && (predicate == null || predicate(tnode, argument)))
                    return tnode;
            }

            return null;
        }

        public global::System.Collections.Generic.IEnumerable<{{ red_base.csharp | not_null }}> DescendantNodes(Func<{{ red_base.csharp | not_null }}, bool>? descendIntoChildren = null)
        {
            var stack = new Stack<{{ red_base.csharp | not_null }}>(24);
            foreach (var child in this.ChildNodes())
                stack.Push(child);

            while (stack.Count > 0)
            {
                var current = stack.Pop();

                yield return current;

                foreach (var child in current.ChildNodes().Reverse())
                {
                    stack.Push(child);
                }
            }
        }

        public global::System.Collections.Generic.IEnumerable<{{ red_base.csharp | not_null }}> DescendantNodesAndSelf(Func<{{ red_base.csharp | not_null }}, bool>? descendIntoChildren = null)
        {
            var stack = new Stack<{{ red_base.csharp | not_null }}>(24);
            stack.Push(this);

            while (stack.Count > 0)
            {
                var current = stack.Pop();

                yield return current;

                foreach (var child in current.ChildNodes().Reverse())
                {
                    stack.Push(child);
                }
            }
        }
    }
}
