// Copyright © 2024 GGG KILLER <gggkiller2@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the “Software”), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Tsu.Trees.RedGreen.SourceGenerator.Model;

namespace Tsu.Trees.RedGreen.SourceGenerator;

internal static class GreenTreeGenerator
{
    public static void ValidateTrees(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        // TODO: Implement
        return;
    }

    public static void RegisterGreenOutput(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        context.RegisterSourceOutput(trees, (ctx, tree) =>
        {
            var builder = new StringBuilder();
            var writer = new IndentedTextWriter(new StringWriter(builder));

            writer.WriteLine("// <auto-generated />");
            writer.WriteLineNoTabs("");

            writer.WriteLine("#nullable enable");
            writer.WriteLineNoTabs("");

            writer.WriteLine("using System.Diagnostics;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Linq;");
            writer.WriteLineNoTabs("");

            writer.WriteLine("namespace {0}", tree.GreenBase.ContainingNamespace.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;

            writer.WriteLineNoTabs("");
            writer.WriteGreenFactory(tree);

            if (tree.CreateVisitors)
            {
                writer.WriteLineNoTabs("");
                writer.WriteVisitors(tree, tree.GreenBase);
            }

            if (tree.CreateWalker)
            {
                writer.WriteLineNoTabs("");
                writer.WriteWalker(tree, tree.GreenBase);
            }

            if (tree.CreateRewriter)
            {
                writer.WriteLineNoTabs("");
                writer.WriteRewriter(tree, tree.RedBase);
            }

            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");

            writer.Flush();
            ctx.AddSource($"{tree.Suffix}/Internal/Visitors.g.cs", builder.ToSourceText());
        });
    }
    private static void WriteGreenFactory(this IndentedTextWriter writer, Tree tree)
    {
        writer.WriteLine("{0} static class {1}Factory", tree.GreenBase.DeclaredAccessibility.ToCSharpString(), tree.Suffix);
        writer.WriteLine('{');
        writer.Indent++;
        {
            var queue = new Queue<Node>();
            foreach (var desc in tree.Root.Descendants)
                queue.Enqueue(desc);

            var first = true;
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (node.Descendants.Any())
                {
                    foreach (var desc in node.Descendants)
                        queue.Enqueue(desc);
                }
                else
                {
                    if (!first) writer.WriteLineNoTabs("");
                    first = false;
                    writer.WriteGreenFactoryMethods(tree, node);
                }
            }
        }
        writer.Indent--;
        writer.WriteLine('}');
    }

    private static void WriteGreenFactoryMethods(this IndentedTextWriter writer, Tree tree, Node node)
    {
        if (node.RequiredComponents.Any(x => x.IsOptional))
        {
            writeMethod(writer, tree, node, false);
            writer.WriteLineNoTabs("");
        }
        writeMethod(writer, tree, node, true);

        static void writeMethod(IndentedTextWriter writer, Tree tree, Node node, bool includeOptional)
        {
            writer.Write("public static {0} {1}(", node.TypeSymbol.ToCSharpString(), node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));
            var first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;
                writer.Write("{0} {1}", component.Type.ToCSharpString(), component.ParameterName);
            }
            writer.WriteLine(')');
            writer.WriteLine('{');
            writer.Indent++;
            {
                writer.WriteLineNoTabs("#if DEBUG");
                foreach (var component in node.RequiredComponents.Where(x => !x.Type.IsValueType))
                {
                    if (component.IsOptional) continue;
                    writer.WriteLine("if ({0} == null) throw new global::System.ArgumentNullException(nameof({0}));", component.ParameterName);
                }
                if (node.Kinds.Length != 1)
                {
                    writer.WriteLine("switch (kind)");
                    writer.WriteLine('{');
                    writer.Indent++;
                    {
                        foreach (var kind in node.Kinds)
                            writer.WriteLine("case {0}:", kind.ToCSharpString());
                        writer.Indent++;
                        writer.WriteLine("break;");
                        writer.Indent--;
                        writer.WriteLine("default:");
                        writer.Indent++;
                        writer.WriteLine("throw new global::System.ArgumentException(\"Kind not accepted for this node.\", nameof(kind));");
                        writer.Indent--;
                    }
                    writer.Indent--;
                    writer.WriteLine('}');
                }
                writer.WriteLineNoTabs("#endif // DEBUG");
                writer.WriteLineNoTabs("");

                writer.WriteLine("return new {0}(", node.TypeSymbol.ToCSharpString());
                first = true;
                if (node.Kinds.Length == 1)
                {
                    first = false;
                    writer.Write("global::{0}", node.Kinds[0].ToCSharpString());
                }
                foreach (var component in node.RequiredComponents)
                {
                    if (!first) writer.Write(", ");
                    first = false;
                    if (component.IsOptional && !includeOptional)
                        writer.Write("default");
                    else
                        writer.Write(component.ParameterName);
                }
                writer.WriteLine(");");
            }
            writer.Indent--;
            writer.WriteLine('}');
        }
    }
}