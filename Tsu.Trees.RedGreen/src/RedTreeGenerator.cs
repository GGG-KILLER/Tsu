// Copyright © 2024 GGG KILLER <gggkiller2@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the “Software”), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Tsu.Trees.RedGreen.SourceGenerator.Model;

namespace Tsu.Trees.RedGreen.SourceGenerator;

internal static class RedTreeGenerator
{
    public static void RegisterRedTreeOutput(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        context.RegisterSourceOutput(trees, (ctx, tree) =>
        {
            var builder = new StringBuilder();
            var writer = new IndentedTextWriter(new StringWriter(builder));

            writer.WriteLine("// <auto-generated />");
            writer.WriteLineNoTabs("");

            writer.WriteLine("#nullable enable");
            writer.WriteLineNoTabs("");

            writer.WriteLine("using System.Diagnostics;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Linq;");
            writer.WriteLineNoTabs("");

            writer.WriteLine("namespace {0}", tree.RedBase.ContainingNamespace.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                var stack = new Stack<Node>();
                foreach (var desc in tree.Root.Descendants)
                    stack.Push(desc);
                while (stack.Count > 0)
                {
                    var node = stack.Pop();
                    foreach (var desc in node.Descendants)
                        stack.Push(desc);

                    writer.WriteLineNoTabs("");
                    writer.WriteRedNode(tree, node);
                }
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");

            writer.Flush();
            ctx.AddSource($"{tree.Suffix}.Red.g.cs", builder.ToSourceText());
        });
    }

    public static void RegisterRedMainOutput(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        context.RegisterSourceOutput(trees, (ctx, tree) =>
        {
            var builder = new StringBuilder();
            var writer = new IndentedTextWriter(new StringWriter(builder));

            writer.WriteLine("// <auto-generated />");
            writer.WriteLineNoTabs("");

            writer.WriteLine("#nullable enable");
            writer.WriteLineNoTabs("");

            writer.WriteLine("using System.Diagnostics;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Linq;");
            writer.WriteLineNoTabs("");

            writer.WriteLine("namespace {0}", tree.RedBase.ContainingNamespace.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                if (tree.CreateVisitors)
                {
                    writer.WriteVisitors(tree, tree.RedBase);
                    writer.WriteLineNoTabs("");
                }

                if (tree.CreateWalker)
                {
                    writer.WriteWalker(tree, tree.RedBase);
                    writer.WriteLineNoTabs("");
                }

                if (tree.CreateRewriter)
                {
                    writer.WriteLineNoTabs("");
                    writer.WriteRewriter(tree, tree.RedBase);
                }

                writer.WriteRedFactory(tree);
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");

            writer.Flush();
            ctx.AddSource($"{tree.Suffix}.Main.g.cs", builder.ToSourceText());
        });
    }

    private static void WriteRedNode(this IndentedTextWriter writer, Tree tree, Node node)
    {
        var nodeBase = node.BaseSymbol;
        if (SymbolEqualityComparer.Default.Equals(nodeBase, tree.GreenBase))
            nodeBase = tree.RedBase;

        writer.WriteLine("{0} {1} partial class {2} : {3}.{4}",
            tree.RedBase.DeclaredAccessibility.ToCSharpString(),
            node.Descendants.Length > 0 ? "abstract" : "sealed",
            node.TypeSymbol.Name,
            tree.RedBase.ContainingNamespace.ToCSharpString(false),
            nodeBase!.Name);
        writer.WriteLine('{');
        writer.Indent++;
        {
            if (node.Descendants.Length == 0)
            {
                foreach (var child in node.Children)
                {
                    writer.WriteLine("private {0}.{1}? {2};",
                        tree.RedBase.ContainingNamespace.ToCSharpString(false),
                        child.Type.Name,
                        child.FieldName);
                }
                writer.WriteLineNoTabs("");
            }

            writer.WriteLines($$"""
                internal {{node.TypeSymbol.Name}}({{tree.GreenBase.ToCSharpString()}} green, {{tree.RedBase.ToCSharpString()}}? parent)
                    : base(green, parent)
                {
                }

                """);

            #region Components
            if (node.Descendants.Length > 0)
            {
                foreach (var component in node.NodeComponents)
                {
                    var ns = component.Type.ContainingNamespace;
                    if (component.Type.DerivesFrom(tree.GreenBase))
                        ns = tree.RedBase.ContainingNamespace;
                    writer.WriteLine($"public abstract {ns.ToCSharpString(false)}.{component.Type.Name}{(component.IsOptional ? "?" : "")} {component.PropertyName} {{ get; }}");
                }
            }
            else
            {
                foreach (var extra in node.ExtraData)
                {
                    if (extra.FieldName == "_kind") continue;

                    writer.WriteLine("public {0}{1} {2} => (({3})this.Green).{2};",
                        extra.PassToBase ? "override " : "",
                        extra.Type.ToCSharpString(),
                        extra.PropertyName,
                        node.TypeSymbol.ToCSharpString(false));
                }
                for (var idx = 0; idx < node.Children.Length; idx++)
                {
                    var child = node.Children[idx];
                    writer.WriteLine("public {0}{1}.{2} {3} => GetRed(ref this.{4}, {5}){6};",
                        child.PassToBase ? "override " : "",
                        tree.RedBase.ContainingNamespace.ToCSharpString(false),
                        child.Type.Name + (child.IsOptional ? "?" : ""),
                        child.PropertyName,
                        child.FieldName,
                        idx,
                        child.IsOptional ? "" : "!");
                }
            }
            writer.WriteLineNoTabs("");
            #endregion Components

            #region TRedRoot? GetNodeSlot(int index)
            if (node.Descendants.Length == 0)
            {
                writer.WriteLine("internal override {0}? GetNodeSlot(int index) =>", tree.RedBase.ToCSharpString());
                writer.Indent++;
                if (node.Children.Length == 1)
                {
                    writer.Indent++;
                    writer.WriteLine("index == 1 ? GetRed(ref this.{0}, 1){1} : null;",
                        node.Children[0].FieldName,
                        node.Children[0].IsOptional ? "" : "!");
                    writer.Indent--;
                }
                else
                {
                    writer.WriteLine("index switch");
                    writer.WriteLine('{');
                    writer.Indent++;
                    {
                        for (var idx = 0; idx < node.Children.Length; idx++)
                        {
                            var child = node.Children[idx];
                            writer.WriteLine("{0} => GetRed(ref this.{1}, {0}){2},", idx, child.FieldName, child.IsOptional ? "" : "!");
                        }
                        writer.WriteLine("_ => null");
                    }
                    writer.Indent--;
                    writer.WriteLine("};");
                }
                writer.Indent--;
            }
            #endregion TRedRoot? GetNodeSlot(int index)

            #region T Accept(Visitor visitor)
            if (node.Descendants.Length == 0)
            {
                writer.WriteOverrideAcceptMethods(tree, tree.RedBase.ContainingNamespace, node);
            }
            #endregion T Accept(Visitor visitor)

            #region TNode Update(...)
            if (node.Descendants.Length == 0 && node.RequiredComponents.Any())
            {
                writer.WriteLineNoTabs("");
                writer.Write("public {0}.{1} Update(", tree.RedBase.ContainingNamespace.ToCSharpString(false), node.TypeSymbol.Name);
                var first = true;
                foreach (var component in node.RequiredComponents)
                {
                    if (!first) writer.Write(", ");
                    first = false;

                    var ns = component.Type.ContainingNamespace;
                    var name = component.Type.Name;
                    if (component.Type.DerivesFrom(tree.GreenBase))
                    {
                        ns = tree.RedBase.ContainingNamespace;
                    }

                    writer.Write("{0}.{1}{2} {3}",
                        ns.ToCSharpString(false),
                        name,
                        component.IsOptional ? "?" : "",
                        component.ParameterName);
                }
                writer.WriteLine(')');
                writer.WriteLine('{');
                writer.Indent++;
                {
                    writer.Write("if (");
                    first = true;
                    foreach (var component in node.RequiredComponents)
                    {
                        if (!first) writer.Write(" && ");
                        first = false;
                        writer.Write("{0} != this.{1}", component.ParameterName, component.PropertyName);
                    }
                    writer.WriteLine(')');
                    writer.WriteLine('{');
                    writer.Indent++;
                    {
                        writer.Write("return global::{0}.{1}Factory.{2}(",
                            tree.RedBase.ContainingNamespace.ToCSharpString(),
                            tree.Suffix,
                            node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));
                        first = true;
                        foreach (var component in node.RequiredComponents)
                        {
                            if (!first) writer.Write(", ");
                            first = false;
                            writer.Write(component.ParameterName);
                        }
                        writer.WriteLine(");");
                    }
                    writer.Indent--;
                    writer.WriteLine('}');
                    writer.WriteLineNoTabs("");
                    writer.WriteLine("return this;");
                }
                writer.Indent--;
                writer.WriteLine('}');
            }
            #endregion TNode Update(...)

            #region TNode WithX(...)
            if (node.Descendants.Length == 0 && node.RequiredComponents.Any())
            {
                var components = node.RequiredComponents.ToImmutableArray();
                for (var targetIdx = 0; targetIdx < components.Length; targetIdx++)
                {
                    var target = components[targetIdx];
                    var isNode = target.Type.DerivesFrom(tree.GreenBase);

                    writer.WriteLineNoTabs("");
                    writer.Write("public {0}.{1} With{2}({3}.{4}{5} {6}) => this.Update(",
                        tree.RedBase.ContainingNamespace.ToCSharpString(false),
                        node.TypeSymbol.Name,
                        target.PropertyName,
                        (isNode ? tree.RedBase.ContainingNamespace : target.Type.ContainingNamespace).ToCSharpString(false),
                        target.Type.Name,
                        target.IsOptional ? "?" : "",
                        target.ParameterName);
                    var first = true;
                    for (var idx = 0; idx < components.Length; idx++)
                    {
                        var component = components[idx];
                        if (!first) writer.Write(", ");
                        first = false;

                        if (targetIdx == idx) writer.Write(component.ParameterName);
                        else writer.Write("this.{0}", component.PropertyName);
                    }
                    writer.WriteLine(");");
                }
            }
            #endregion TNode WithX(...)
        }
        writer.Indent--;
        writer.WriteLine('}');
    }

    private static void WriteRedFactory(this IndentedTextWriter writer, Tree tree)
    {
        writer.WriteLine("{0} static class {1}Factory", tree.RedBase.DeclaredAccessibility.ToCSharpString(), tree.Suffix);
        writer.WriteLine('{');
        writer.Indent++;
        {
            var queue = new Queue<Node>();
            foreach (var desc in tree.Root.Descendants)
                queue.Enqueue(desc);

            var first = true;
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (node.Descendants.Any())
                {
                    foreach (var desc in node.Descendants)
                        queue.Enqueue(desc);
                }
                else
                {
                    if (!first) writer.WriteLineNoTabs("");
                    first = false;
                    writer.WriteRedFactoryMethods(tree, node);
                }
            }
        }
        writer.Indent--;
        writer.WriteLine('}');
    }

    private static void WriteRedFactoryMethods(this IndentedTextWriter writer, Tree tree, Node node)
    {
        if (node.RequiredComponents.Any(x => x.IsOptional))
        {
            writeMethod(writer, tree, node, false);
            writer.WriteLineNoTabs("");
        }
        writeMethod(writer, tree, node, true);

        static void writeMethod(IndentedTextWriter writer, Tree tree, Node node, bool includeOptional)
        {
            writer.Write("public static {0}.{1} {2}(",
                tree.RedBase.ContainingNamespace.ToCSharpString(false),
                node.TypeSymbol.Name,
                node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));

            var first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;

                var ns = component.Type.ContainingNamespace;
                if (component.Type.DerivesFrom(tree.GreenBase))
                    ns = tree.RedBase.ContainingNamespace;

                writer.Write("{0}.{1}{2} {3}",
                    ns.ToCSharpString(false),
                    component.Type.Name,
                    component.IsOptional ? "?" : "",
                    component.ParameterName);
            }
            writer.WriteLine(") =>");
            writer.Indent++;
            writer.Write("({0}.{1}) {2}.{3}Factory.{4}(",
                tree.RedBase.ContainingNamespace.ToCSharpString(false),
                node.TypeSymbol.Name,
                tree.GreenBase.ContainingNamespace.ToCSharpString(false),
                tree.Suffix,
                node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));

            first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;

                if (component.Type.DerivesFrom(tree.GreenBase))
                {
                    if (component.IsOptional)
                    {
                        writer.Write("{0} == null ? null : ({1}){0}.Green",
                            component.ParameterName,
                            component.Type.ToCSharpString(false));
                    }
                    else
                    {
                        writer.Write("({0}){1}.Green",
                            component.Type.ToCSharpString(false),
                            component.ParameterName);
                    }
                }
                else
                {
                    writer.Write(component.ParameterName);
                }
            }
            writer.WriteLine(").CreateRed();");
            writer.Indent--;
        }
    }
}