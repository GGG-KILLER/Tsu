// Copyright © 2024 GGG KILLER <gggkiller2@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the “Software”), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Tsu.Trees.RedGreen.SourceGenerator.Model;

namespace Tsu.Trees.RedGreen.SourceGenerator;

internal static class RedTreeGenerator
{
    public static void RegisterRedMainOutput(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        context.RegisterSourceOutput(trees, (ctx, tree) =>
        {
            var builder = new StringBuilder();
            var writer = new IndentedTextWriter(new StringWriter(builder));

            try
            {
                writer.WriteLine("// <auto-generated />");
                writer.WriteLineNoTabs("");

                writer.WriteLine("#nullable enable");
                writer.WriteLineNoTabs("");

                writer.WriteLine("using System.Diagnostics;");
                writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
                writer.WriteLine("using System.Linq;");
                writer.WriteLine($"using {tree.GreenBase.ContainingNamespace.ToCSharpString(true)};");
                writer.WriteLineNoTabs("");

                writer.WriteLine("namespace {0}", tree.RedBase.ContainingNamespace.ToCSharpString());
                writer.WriteLine('{');
                writer.Indent++;
                {
                    if (tree.CreateVisitors)
                    {
                        writer.WriteVisitors(tree, false);
                        writer.WriteLineNoTabs("");
                    }

                    if (tree.CreateWalker)
                    {
                        writer.WriteWalker(tree, false);
                        writer.WriteLineNoTabs("");
                    }

                    if (tree.CreateRewriter)
                    {
                        writer.WriteLineNoTabs("");
                        writer.WriteRewriter(tree, false);
                    }

                    writer.WriteRedFactory(tree);
                }
                writer.Indent--;
                writer.WriteLine('}');
                writer.WriteLineNoTabs("");
            }
            catch (Exception ex)
            {
                writer.WriteLineNoTabs("");
                writer.WriteLineNoTabs(ex.ToString());
            }

            writer.Flush();
            ctx.AddSource($"{tree.Suffix}/Main.g.cs", builder.ToSourceText());
        });
    }

    private static void WriteRedFactory(this IndentedTextWriter writer, Tree tree)
    {
        writer.WriteLine("{0} static class {1}Factory", tree.RedBase.DeclaredAccessibility.ToCSharpString(), tree.Suffix);
        writer.WriteLine('{');
        writer.Indent++;
        {
            var queue = new Queue<Node>();
            foreach (var desc in tree.Root.Descendants)
                queue.Enqueue(desc);

            var first = true;
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (node.Descendants.Any())
                {
                    foreach (var desc in node.Descendants)
                        queue.Enqueue(desc);
                }
                else
                {
                    if (!first) writer.WriteLineNoTabs("");
                    first = false;
                    writer.WriteRedFactoryMethods(tree, node);
                }
            }
        }
        writer.Indent--;
        writer.WriteLine('}');
    }

    private static void WriteRedFactoryMethods(this IndentedTextWriter writer, Tree tree, Node node)
    {
        if (node.RequiredComponents.Any(x => x.IsOptional))
        {
            writeMethod(writer, tree, node, false);
            writer.WriteLineNoTabs("");
        }
        writeMethod(writer, tree, node, true);

        static void writeMethod(IndentedTextWriter writer, Tree tree, Node node, bool includeOptional)
        {
            writer.Write("public static {0}.{1} {2}(",
                tree.RedBase.ContainingNamespace.ToCSharpString(false),
                node.TypeSymbol.Name,
                node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));

            var first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;

                var ns = component.Type.ContainingNamespace;
                if (component.Type.DerivesFrom(tree.GreenBase))
                    ns = tree.RedBase.ContainingNamespace;

                var type = tree.ToRedCSharp(component.Type);
                if (component.IsList && component.Type.DerivesFrom(tree.GreenBase))
                    type = $"{ns.ToCSharpString(false)}.{tree.Suffix}List<{type}>";

                writer.Write("{0} {1}",
                    type,
                    component.ParameterName);
            }
            writer.WriteLine(") =>");
            writer.Indent++;
            writer.Write("({0}) {1}.{2}Factory.{3}(",
                tree.ToRedCSharp(node.TypeSymbol),
                tree.GreenBase.ContainingNamespace.ToCSharpString(false),
                tree.Suffix,
                node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));

            first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;

                if (component.Type.DerivesFrom(tree.GreenBase))
                {
                    if (!component.IsList)
                    {
                        if (component.IsOptional)
                            writer.Write("{0} == null ? null : ", component.ParameterName);
                        writer.Write("({0})", component.Type.ToCSharpString(false));
                    }
                    writer.Write("{0}.{1}",
                        component.ParameterName,
                        component.IsList ? $"Node.To{tree.Suffix}List<{component.Type.ToCSharpString()}>()" : "Green");
                }
                else
                {
                    writer.Write(component.ParameterName);
                }
            }
            writer.WriteLine(").CreateRed();");
            writer.Indent--;
        }
    }
}