// Copyright © 2024 GGG KILLER <gggkiller2@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the “Software”), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Tsu.Trees.RedGreen.SourceGenerator.Model;

namespace Tsu.Trees.RedGreen.SourceGenerator;

internal static class RedTreeGenerator
{
    public static void RegisterRedMainOutput(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Tree> trees)
    {
        context.RegisterSourceOutput(trees, (ctx, tree) =>
        {
            var builder = new StringBuilder();
            var writer = new IndentedTextWriter(new StringWriter(builder));

            writer.WriteLine("// <auto-generated />");
            writer.WriteLineNoTabs("");

            writer.WriteLine("#nullable enable");
            writer.WriteLineNoTabs("");

            writer.WriteLine("using System.Diagnostics;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Linq;");
            writer.WriteLineNoTabs("");

            writer.WriteLine("namespace {0}", tree.RedBase.ContainingNamespace.ToCSharpString());
            writer.WriteLine('{');
            writer.Indent++;
            {
                if (tree.CreateVisitors)
                {
                    writer.WriteVisitors(tree, tree.RedBase);
                    writer.WriteLineNoTabs("");
                }

                if (tree.CreateWalker)
                {
                    writer.WriteWalker(tree, tree.RedBase);
                    writer.WriteLineNoTabs("");
                }

                if (tree.CreateRewriter)
                {
                    writer.WriteLineNoTabs("");
                    writer.WriteRewriter(tree, tree.RedBase);
                }

                writer.WriteRedFactory(tree);
            }
            writer.Indent--;
            writer.WriteLine('}');
            writer.WriteLineNoTabs("");

            writer.Flush();
            ctx.AddSource($"{tree.Suffix}/Main.g.cs", builder.ToSourceText());
        });
    }

    private static void WriteRedFactory(this IndentedTextWriter writer, Tree tree)
    {
        writer.WriteLine("{0} static class {1}Factory", tree.RedBase.DeclaredAccessibility.ToCSharpString(), tree.Suffix);
        writer.WriteLine('{');
        writer.Indent++;
        {
            var queue = new Queue<Node>();
            foreach (var desc in tree.Root.Descendants)
                queue.Enqueue(desc);

            var first = true;
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (node.Descendants.Any())
                {
                    foreach (var desc in node.Descendants)
                        queue.Enqueue(desc);
                }
                else
                {
                    if (!first) writer.WriteLineNoTabs("");
                    first = false;
                    writer.WriteRedFactoryMethods(tree, node);
                }
            }
        }
        writer.Indent--;
        writer.WriteLine('}');
    }

    private static void WriteRedFactoryMethods(this IndentedTextWriter writer, Tree tree, Node node)
    {
        if (node.RequiredComponents.Any(x => x.IsOptional))
        {
            writeMethod(writer, tree, node, false);
            writer.WriteLineNoTabs("");
        }
        writeMethod(writer, tree, node, true);

        static void writeMethod(IndentedTextWriter writer, Tree tree, Node node, bool includeOptional)
        {
            writer.Write("public static {0}.{1} {2}(",
                tree.RedBase.ContainingNamespace.ToCSharpString(false),
                node.TypeSymbol.Name,
                node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));

            var first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;

                var ns = component.Type.ContainingNamespace;
                if (component.Type.DerivesFrom(tree.GreenBase))
                    ns = tree.RedBase.ContainingNamespace;

                writer.Write("{0}.{1}{2} {3}",
                    ns.ToCSharpString(false),
                    component.Type.Name,
                    component.IsOptional ? "?" : "",
                    component.ParameterName);
            }
            writer.WriteLine(") =>");
            writer.Indent++;
            writer.Write("({0}.{1}) {2}.{3}Factory.{4}(",
                tree.RedBase.ContainingNamespace.ToCSharpString(false),
                node.TypeSymbol.Name,
                tree.GreenBase.ContainingNamespace.ToCSharpString(false),
                tree.Suffix,
                node.TypeSymbol.Name.WithoutSuffix(tree.Suffix));

            first = true;
            foreach (var component in node.RequiredComponents)
            {
                if (!includeOptional && component.IsOptional) continue;
                if (!first) writer.Write(", ");
                first = false;

                if (component.Type.DerivesFrom(tree.GreenBase))
                {
                    if (component.IsOptional)
                    {
                        writer.Write("{0} == null ? null : ({1}){0}.Green",
                            component.ParameterName,
                            component.Type.ToCSharpString(false));
                    }
                    else
                    {
                        writer.Write("({0}){1}.Green",
                            component.Type.ToCSharpString(false),
                            component.ParameterName);
                    }
                }
                else
                {
                    writer.Write(component.ParameterName);
                }
            }
            writer.WriteLine(").CreateRed();");
            writer.Indent--;
        }
    }
}